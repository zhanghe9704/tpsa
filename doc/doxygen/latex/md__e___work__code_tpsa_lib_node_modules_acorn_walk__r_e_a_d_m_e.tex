An abstract syntax tree walker for the \href{https://github.com/estree/estree}{\texttt{ ESTree}} format.\hypertarget{md__e___work__code_tpsa_lib_node_modules_acorn_walk__r_e_a_d_m_e_autotoc_md433}{}\doxysection{Community}\label{md__e___work__code_tpsa_lib_node_modules_acorn_walk__r_e_a_d_m_e_autotoc_md433}
Acorn is open source software released under an \href{https://github.com/acornjs/acorn/blob/master/acorn-walk/LICENSE}{\texttt{ MIT license}}.

You are welcome to \href{https://github.com/acornjs/acorn/issues}{\texttt{ report bugs}} or create pull requests on \href{https://github.com/acornjs/acorn}{\texttt{ github}}. For questions and discussion, please use the \href{https://discuss.ternjs.net}{\texttt{ Tern discussion forum}}.\hypertarget{md__e___work__code_tpsa_lib_node_modules_acorn_walk__r_e_a_d_m_e_autotoc_md434}{}\doxysection{Installation}\label{md__e___work__code_tpsa_lib_node_modules_acorn_walk__r_e_a_d_m_e_autotoc_md434}
The easiest way to install acorn is from \href{https://www.npmjs.com/}{\texttt{ {\ttfamily npm}}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{npm install acorn-\/walk}

\end{DoxyCode}


Alternately, you can download the source and build acorn yourself\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{git clone https://github.com/acornjs/acorn.git}
\DoxyCodeLine{cd acorn}
\DoxyCodeLine{npm install}

\end{DoxyCode}
\hypertarget{md__e___work__code_tpsa_lib_node_modules_acorn_walk__r_e_a_d_m_e_autotoc_md435}{}\doxysection{Interface}\label{md__e___work__code_tpsa_lib_node_modules_acorn_walk__r_e_a_d_m_e_autotoc_md435}
An algorithm for recursing through a syntax tree is stored as an object, with a property for each tree node type holding a function that will recurse through such a node. There are several ways to run such a walker.

{\bfseries{simple}}{\ttfamily (node, visitors, base, state)} does a \textquotesingle{}simple\textquotesingle{} walk over a tree. {\ttfamily node} should be the AST node to walk, and {\ttfamily visitors} an object with properties whose names correspond to node types in the \href{https://github.com/estree/estree}{\texttt{ ESTree spec}}. The properties should contain functions that will be called with the node object and, if applicable the state at that point. The last two arguments are optional. {\ttfamily base} is a walker algorithm, and {\ttfamily state} is a start state. The default walker will simply visit all statements and expressions and not produce a meaningful state. (An example of a use of state is to track scope at each point in the tree.)


\begin{DoxyCode}{0}
\DoxyCodeLine{const acorn = require("{}acorn"{})}
\DoxyCodeLine{const walk = require("{}acorn-\/walk"{})}
\DoxyCodeLine{}
\DoxyCodeLine{walk.simple(acorn.parse("{}let x = 10"{}), \{}
\DoxyCodeLine{  Literal(node) \{}
\DoxyCodeLine{    console.log(`Found a literal: \$\{node.value\}`)}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\})}

\end{DoxyCode}


{\bfseries{ancestor}}{\ttfamily (node, visitors, base, state)} does a \textquotesingle{}simple\textquotesingle{} walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to the callbacks as a third parameter.


\begin{DoxyCode}{0}
\DoxyCodeLine{const acorn = require("{}acorn"{})}
\DoxyCodeLine{const walk = require("{}acorn-\/walk"{})}
\DoxyCodeLine{}
\DoxyCodeLine{walk.ancestor(acorn.parse("{}foo('hi')"{}), \{}
\DoxyCodeLine{  Literal(\_, ancestors) \{}
\DoxyCodeLine{    console.log("{}This literal's ancestors are:"{}, ancestors.map(n => n.type))}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\})}

\end{DoxyCode}


{\bfseries{recursive}}{\ttfamily (node, state, functions, base)} does a \textquotesingle{}recursive\textquotesingle{} walk, where the walker functions are responsible for continuing the walk on the child nodes of their target node. {\ttfamily state} is the start state, and {\ttfamily functions} should contain an object that maps node types to walker functions. Such functions are called with {\ttfamily (node, state, c)} arguments, and can cause the walk to continue on a sub-\/node by calling the {\ttfamily c} argument on it with {\ttfamily (node, state)} arguments. The optional {\ttfamily base} argument provides the fallback walker functions for node types that aren\textquotesingle{}t handled in the {\ttfamily functions} object. If not given, the default walkers will be used.

{\bfseries{make}}{\ttfamily (functions, base)} builds a new walker object by using the walker functions in {\ttfamily functions} and filling in the missing ones by taking defaults from {\ttfamily base}.

{\bfseries{full}}{\ttfamily (node, callback, base, state)} does a \textquotesingle{}full\textquotesingle{} walk over a tree, calling the callback with the arguments (node, state, type) for each node

{\bfseries{full\+Ancestor}}{\ttfamily (node, callback, base, state)} does a \textquotesingle{}full\textquotesingle{} walk over a tree, building up an array of ancestor nodes (including the current node) and passing the array to the callbacks as a third parameter.


\begin{DoxyCode}{0}
\DoxyCodeLine{const acorn = require("{}acorn"{})}
\DoxyCodeLine{const walk = require("{}acorn-\/walk"{})}
\DoxyCodeLine{}
\DoxyCodeLine{walk.full(acorn.parse("{}1 + 1"{}), node => \{}
\DoxyCodeLine{  console.log(`There's a \$\{node.type\} node at \$\{node.ch\}`)}
\DoxyCodeLine{\})}

\end{DoxyCode}


{\bfseries{find\+Node\+At}}{\ttfamily (node, start, end, test, base, state)} tries to locate a node in a tree at the given start and/or end offsets, which satisfies the predicate {\ttfamily test}. {\ttfamily start} and {\ttfamily end} can be either {\ttfamily null} (as wildcard) or a number. {\ttfamily test} may be a string (indicating a node type) or a function that takes {\ttfamily (node\+Type, node)} arguments and returns a boolean indicating whether this node is interesting. {\ttfamily base} and {\ttfamily state} are optional, and can be used to specify a custom walker. Nodes are tested from inner to outer, so if two nodes match the boundaries, the inner one will be preferred.

{\bfseries{find\+Node\+Around}}{\ttfamily (node, pos, test, base, state)} is a lot like {\ttfamily find\+Node\+At}, but will match any node that exists \textquotesingle{}around\textquotesingle{} (spanning) the given position.

{\bfseries{find\+Node\+After}}{\ttfamily (node, pos, test, base, state)} is similar to {\ttfamily find\+Node\+Around}, but will match all nodes {\itshape after} the given position (testing outer nodes before inner nodes). 