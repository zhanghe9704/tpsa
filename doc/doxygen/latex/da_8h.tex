\hypertarget{da_8h}{}\doxysection{E\+:/\+Work/\+Code/tpsa\+\_\+lib/include/da.h File Reference}
\label{da_8h}\index{E:/Work/Code/tpsa\_lib/include/da.h@{E:/Work/Code/tpsa\_lib/include/da.h}}


DA wrapper for the extended tpsa code.  


{\ttfamily \#include $<$complex$>$}\newline
{\ttfamily \#include $<$memory$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_d_a_vector}{DAVector}}
\begin{DoxyCompactList}\small\item\em Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_base}{Base}}
\begin{DoxyCompactList}\small\item\em Bases for DA calculations. The i-\/th base can be accessed as base\mbox{[}i\mbox{]}, where base is an object of \mbox{\hyperlink{struct_base}{Base}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{da_8h_ad61827eba074ba0f0a85811822025887}{da\+\_\+init}} (unsigned int da\+\_\+order, unsigned int num\+\_\+da\+\_\+variables, unsigned int num\+\_\+da\+\_\+vectors, bool table=true)
\begin{DoxyCompactList}\small\item\em Initialize the DA environment. This function initialize the DA environment w.\+r.\+t. the given DA order and the number of bases. A memory pool is created for the given number of DA vectors, which should be large enough for perspective calculations. \mbox{\hyperlink{struct_base}{Base}} vectors are also created. The i-\/th base can be accessed as da\mbox{[}i\mbox{]}. This function should be called before any DA calculation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_a4ce8ca67305300c7278dc9f4c56483db}{da\+\_\+clear}} ()
\begin{DoxyCompactList}\small\item\em Destroy the DA environment and release memory. This function should only be called when all the DAVectors are out of scope. Otherwise it will cause a segment fault. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_a66dc266cb3b691feba5cc6d2caa0a439}\label{da_8h_a66dc266cb3b691feba5cc6d2caa0a439}} 
int \mbox{\hyperlink{da_8h_a66dc266cb3b691feba5cc6d2caa0a439}{da\+\_\+change\+\_\+order}} (unsigned int new\+\_\+order)
\begin{DoxyCompactList}\small\item\em Temporarily change the DA order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_a6a7bb906427228e825194f28c1ab9e7d}\label{da_8h_a6a7bb906427228e825194f28c1ab9e7d}} 
int \mbox{\hyperlink{da_8h_a6a7bb906427228e825194f28c1ab9e7d}{da\+\_\+restore\+\_\+order}} ()
\begin{DoxyCompactList}\small\item\em Restore the original DA order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_af27498d9051f38e37638962320f465e2}\label{da_8h_af27498d9051f38e37638962320f465e2}} 
int \mbox{\hyperlink{da_8h_af27498d9051f38e37638962320f465e2}{da\+\_\+count}} ()
\begin{DoxyCompactList}\small\item\em Count the number of existing DA Vectors, including the bases. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{da_8h_a7ce0828d83881579af4e2bf2f1c0ae48}{da\+\_\+remain}} ()
\begin{DoxyCompactList}\small\item\em Check the remaining capacity in the DA pool. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_af5bdfa781e8d2130cdd9c17fbb72ae63}\label{da_8h_af5bdfa781e8d2130cdd9c17fbb72ae63}} 
int \mbox{\hyperlink{da_8h_af5bdfa781e8d2130cdd9c17fbb72ae63}{da\+\_\+full\+\_\+length}} ()
\begin{DoxyCompactList}\small\item\em Return the full length of the da vector. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_a105988256f52fb783f4309d85b9c59c0}\label{da_8h_a105988256f52fb783f4309d85b9c59c0}} 
std\+::vector$<$ int $>$ \& \mbox{\hyperlink{da_8h_a105988256f52fb783f4309d85b9c59c0}{da\+\_\+element\+\_\+orders}} (int i)
\begin{DoxyCompactList}\small\item\em Return the orders of each base as a vector for the i-\/th element. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_a1fce1be893d2c00666779278f3ce0967}{da\+\_\+set\+\_\+eps}} (double eps)
\begin{DoxyCompactList}\small\item\em Set the cut-\/off value for DA coefficients.\+If the abs value of an coefficient is less than eps, it will be set to zero. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_a2ccc5e74773f19981185141ac5f89cbf}{da\+\_\+der}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, unsigned int base\+\_\+id, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+der)
\begin{DoxyCompactList}\small\item\em Take derivative of a da vector w.\+r.\+t. a specific base. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_afce2e888b1204dc16e0c1f43311b4b85}{da\+\_\+int}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, unsigned int base\+\_\+id, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+int)
\begin{DoxyCompactList}\small\item\em Integrate a da vector w.\+r.\+t. a specific base. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \mbox{\hyperlink{da_8h_a34a626191c5eb0ff6d9ad13f14fb0e13}{da\+\_\+der}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, unsigned int base\+\_\+id)
\begin{DoxyCompactList}\small\item\em Take derivative of a da vector w.\+r.\+t. a specific base. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \mbox{\hyperlink{da_8h_ab36b8038e76c52468949f8707d3d53cf}{da\+\_\+int}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, unsigned int base\+\_\+id)
\begin{DoxyCompactList}\small\item\em Integrate a da vector w.\+r.\+t. a specific base. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_aada7a3f3aba16d78f60b99266b10e5fa}{da\+\_\+substitute\+\_\+const}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&iv, unsigned int base\+\_\+id, double x, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&ov)
\begin{DoxyCompactList}\small\item\em Substitute the given value to the specific base in a DA vector. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_a9fcd9472006662f06ee3229933c01688}{da\+\_\+substitute}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&iv, unsigned int base\+\_\+id, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&v, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&ov)
\begin{DoxyCompactList}\small\item\em Substitute a DA vector to a specific base in a given DA Vector. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_af25c09dac7cce3378e9b32d29b0f3976}{da\+\_\+substitute}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&iv, std\+::vector$<$ unsigned int $>$ \&base\+\_\+id, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&ov)
\begin{DoxyCompactList}\small\item\em Substitute DA vectors to the specific bases in a DA vector. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_a6d59d2090f0c4361d2178975f2ee30b6}{da\+\_\+substitute}} (std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ivecs, std\+::vector$<$ unsigned int $>$ \&base\+\_\+id, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ovecs)
\begin{DoxyCompactList}\small\item\em Substitute DA vectors to the specific bases in a group of DA vectors. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_ae6865e8dd89daf74239153eb2f4f69b9}{da\+\_\+composition}} (std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ivecs, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ovecs)
\begin{DoxyCompactList}\small\item\em Composition of a group of DA vectors with another group of DA vectors. Calculate the composition of two groups of DA vectors, and save the result into the third group of DA vectors. Call the first group of DA vectors, ivecs, as f, which includes n DA vectors\+: f\+\_\+1, f\+\_\+2, ..., f\+\_\+n. The second group of DA vectors, v, should contain the same number of DA vectors as the number of DA bases. Call the third group of DA vectors, ovecs, as g, which also includes n DA vectors\+: g\+\_\+1, g\+\_\+2, ..., g\+\_\+n. g = f(v), or g\+\_\+1 = f\+\_\+1(v), g\+\_\+2 = f\+\_\+2(v), ..., g\+\_\+n = f\+\_\+n(v). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_adc6fca2f8f28480b828974eb3fc69fee}{da\+\_\+composition}} (std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ivecs, std\+::vector$<$ double $>$ \&v, std\+::vector$<$ double $>$ \&ovecs)
\begin{DoxyCompactList}\small\item\em Submitting all the bases for a group of DA vectors with given values. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{da_8h_af02c5d525c7bebcec8d951edef18fd22}{da\+\_\+composition}} (std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ivecs, std\+::vector$<$ std\+::complex$<$ double $>$$>$ \&v, std\+::vector$<$ std\+::complex$<$ double $>$$>$ \&ovecs)
\begin{DoxyCompactList}\small\item\em Submitting all the bases for a group of DA vectors with given complex values. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_ae1e45f461004cd005a7a314cca60a002}\label{da_8h_ae1e45f461004cd005a7a314cca60a002}} 
void {\bfseries cd\+\_\+composition} (std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ivecs, std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&v, std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&ovecs)
\item 
\mbox{\Hypertarget{da_8h_a1cb8817d3375a316f4c25148e92d54c4}\label{da_8h_a1cb8817d3375a316f4c25148e92d54c4}} 
void {\bfseries cd\+\_\+composition} (std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&ivecs, std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&v, std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&ovecs)
\item 
\mbox{\Hypertarget{da_8h_acf09c9381cc7aacd0ad910e41dce7d8d}\label{da_8h_acf09c9381cc7aacd0ad910e41dce7d8d}} 
void {\bfseries cd\+\_\+composition} (std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&ivecs, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v, std\+::vector$<$ std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$$>$ \&ovecs)
\item 
\mbox{\Hypertarget{da_8h_a380412f4590bd9ad029acab14b71a32c}\label{da_8h_a380412f4590bd9ad029acab14b71a32c}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator+} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, double real\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a76ac349ad9a4f8516abed244410856a7}\label{da_8h_a76ac349ad9a4f8516abed244410856a7}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator+} (double real\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a6a3acf66023083a1958d945823f10407}\label{da_8h_a6a3acf66023083a1958d945823f10407}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator+} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+1, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_aae978b3d1dfc0cabd70bc4679c9044d4}\label{da_8h_aae978b3d1dfc0cabd70bc4679c9044d4}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator$\ast$} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, double real\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a5c3ffacae0935fc15692fdbb0a8652df}\label{da_8h_a5c3ffacae0935fc15692fdbb0a8652df}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator$\ast$} (double real\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a88d8d28af264a5b74f450aad24080f47}\label{da_8h_a88d8d28af264a5b74f450aad24080f47}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator$\ast$} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+1, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_a279411555358efa8242d6e1ab1ba5558}\label{da_8h_a279411555358efa8242d6e1ab1ba5558}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator-\/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, double real\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a56b3db4bf81646c5fafb77ee67410d94}\label{da_8h_a56b3db4bf81646c5fafb77ee67410d94}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator-\/} (double real\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a0b3121d718d77a7721915c819dbf1a03}\label{da_8h_a0b3121d718d77a7721915c819dbf1a03}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator-\/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+1, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_a079613a06cbb7f8a22a310cc1c4b3eab}\label{da_8h_a079613a06cbb7f8a22a310cc1c4b3eab}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, double real\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_af7fe1688315098b5de5b72a0e28711cd}\label{da_8h_af7fe1688315098b5de5b72a0e28711cd}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator/} (double real\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_aa640afa8a708a5b0c62ec69fcb7651d3}\label{da_8h_aa640afa8a708a5b0c62ec69fcb7651d3}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+1, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_a1495476caa72ac68ee3b6d23a7bece29}\label{da_8h_a1495476caa72ac68ee3b6d23a7bece29}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator+} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_ac3661f6529213db43aba76db4fec8fb6}\label{da_8h_ac3661f6529213db43aba76db4fec8fb6}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries operator-\/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_aa3e35b22efe762e7024749f3797c6721}\label{da_8h_aa3e35b22efe762e7024749f3797c6721}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+1, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_ae1ebe8a3b791c5a402e314379a536532}\label{da_8h_ae1ebe8a3b791c5a402e314379a536532}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \& {\bfseries get\+\_\+real} (std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v)
\item 
\mbox{\Hypertarget{da_8h_aefbb070ca45de4747c7c48e81d90df2e}\label{da_8h_aefbb070ca45de4747c7c48e81d90df2e}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \& {\bfseries get\+\_\+imag} (std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v)
\item 
\mbox{\Hypertarget{da_8h_ad89bde943db0203812411b181fac4e2b}\label{da_8h_ad89bde943db0203812411b181fac4e2b}} 
const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \& {\bfseries get\+\_\+real} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v)
\item 
\mbox{\Hypertarget{da_8h_abca43db4fa48da827e9786429baf4478}\label{da_8h_abca43db4fa48da827e9786429baf4478}} 
const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \& {\bfseries get\+\_\+imag} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&v)
\item 
\mbox{\Hypertarget{da_8h_a3572f428f83c4b3e6c25f19722fb8bde}\label{da_8h_a3572f428f83c4b3e6c25f19722fb8bde}} 
void {\bfseries cd\+\_\+copy} (std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&vs, std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&vo)
\item 
\mbox{\Hypertarget{da_8h_afe47eaa37279ac25c2bbe0ce6cce859c}\label{da_8h_afe47eaa37279ac25c2bbe0ce6cce859c}} 
void {\bfseries cd\+\_\+copy} (std\+::complex$<$ double $>$ vs, std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&vo)
\item 
\mbox{\Hypertarget{da_8h_a70d07e06f28f199228c91cea0a9fba69}\label{da_8h_a70d07e06f28f199228c91cea0a9fba69}} 
void {\bfseries cd\+\_\+copy} (double x, std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&vo)
\item 
std\+::string \mbox{\hyperlink{da_8h_a639c9fb588c015dc76640cf52662a3b5}{trim\+\_\+whitespace}} (std\+::string input\+\_\+line)
\begin{DoxyCompactList}\small\item\em Trim the spaces at the head and the tail of the string. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_ad3c745cb37524c30b599d338218628f9}\label{da_8h_ad3c745cb37524c30b599d338218628f9}} 
bool {\bfseries read\+\_\+da\+\_\+from\+\_\+file} (std\+::string filename, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&d)
\item 
\mbox{\Hypertarget{da_8h_a9c9745dc13a421ef599dbb4e928bf249}\label{da_8h_a9c9745dc13a421ef599dbb4e928bf249}} 
bool {\bfseries read\+\_\+cd\+\_\+from\+\_\+file} (std\+::string filename, std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd)
\item 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \mbox{\hyperlink{da_8h_ad2fd76384773f1538658cdfebb4c4a08}{devide\+\_\+by\+\_\+element}} (\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&t, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&b)
\begin{DoxyCompactList}\small\item\em Devide two DA vectors element by element. Devide \mbox{\hyperlink{struct_d_a_vector}{DAVector}} t by \mbox{\hyperlink{struct_d_a_vector}{DAVector}} b element by element. If the the element in b is zero, use the respective element in t as the result for that element. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{da_8h_a9f08d1308badc3e175572d7c25948604}{compare\+\_\+da\+\_\+vectors}} (\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&a, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&b, double eps=1e-\/15)
\begin{DoxyCompactList}\small\item\em Compare two DA vectors. Compare two DA vectors element by element. If the relative error of each element is less than a given value, return true; otherwise return false. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_af460971e8859a611012fb8a6acb68a3b}\label{da_8h_af460971e8859a611012fb8a6acb68a3b}} 
bool {\bfseries compare\+\_\+da\+\_\+with\+\_\+file} (std\+::string filename, \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&d, double eps=1e-\/15)
\item 
\mbox{\Hypertarget{da_8h_a80c90f6e9df851e278c5b96f01939555}\label{da_8h_a80c90f6e9df851e278c5b96f01939555}} 
bool {\bfseries compare\+\_\+cd\+\_\+vectors} (std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&a, std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&b, double eps=1e-\/15)
\item 
\mbox{\Hypertarget{da_8h_ad2b31c069e413acdc1e85379e9644e6f}\label{da_8h_ad2b31c069e413acdc1e85379e9644e6f}} 
bool {\bfseries compare\+\_\+cd\+\_\+with\+\_\+file} (std\+::string filename, std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&d, double eps=1e-\/15)
\item 
\mbox{\Hypertarget{da_8h_a306b77c967e350d26bfd14c392bad82a}\label{da_8h_a306b77c967e350d26bfd14c392bad82a}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a4e7f30865e4604fa4e4318ce863f5360}\label{da_8h_a4e7f30865e4604fa4e4318ce863f5360}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (std\+::complex$<$ double $>$ complex\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_adb588711570ef79ba2f11cd5cd3a3706}\label{da_8h_adb588711570ef79ba2f11cd5cd3a3706}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_ab095559f6cf4c32fee66815aa8d1a2d0}\label{da_8h_ab095559f6cf4c32fee66815aa8d1a2d0}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (std\+::complex$<$ double $>$ complex\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a61a295b5ab9a59b56eba2695943d7a07}\label{da_8h_a61a295b5ab9a59b56eba2695943d7a07}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a88af174d0490e7ce1809054ddf6154eb}\label{da_8h_a88af174d0490e7ce1809054ddf6154eb}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (std\+::complex$<$ double $>$ complex\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a3a030cb1b1e583fc1c0a98fa5689cce6}\label{da_8h_a3a030cb1b1e583fc1c0a98fa5689cce6}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a0889f8068a63b413d047d48a66aa038d}\label{da_8h_a0889f8068a63b413d047d48a66aa038d}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (std\+::complex$<$ double $>$ complex\+\_\+number, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_aea4c82b978f10325b7fb6359a74e33e3}\label{da_8h_aea4c82b978f10325b7fb6359a74e33e3}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, double number)
\item 
\mbox{\Hypertarget{da_8h_ad747d7ab48404f2c25bbfa3258b310d1}\label{da_8h_ad747d7ab48404f2c25bbfa3258b310d1}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (double number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a0cc40782469bece967f0de161d60c4ac}\label{da_8h_a0cc40782469bece967f0de161d60c4ac}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, double number)
\item 
\mbox{\Hypertarget{da_8h_a58f4fa207a0d652c61a33060c1ba3edf}\label{da_8h_a58f4fa207a0d652c61a33060c1ba3edf}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (double number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_aa095d438f710ea05bb1ec5813e7cf71a}\label{da_8h_aa095d438f710ea05bb1ec5813e7cf71a}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, double number)
\item 
\mbox{\Hypertarget{da_8h_ab2a79f050aac91d8ca176ffac425d59f}\label{da_8h_ab2a79f050aac91d8ca176ffac425d59f}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (double number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_af3a873589f18d9a593c137332324062e}\label{da_8h_af3a873589f18d9a593c137332324062e}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, double number)
\item 
\mbox{\Hypertarget{da_8h_a9e6c2b721adcdcc824b68cdccc1f15b2}\label{da_8h_a9e6c2b721adcdcc824b68cdccc1f15b2}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (double number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a9fb13c4ea6c76278d7404cacc032167c}\label{da_8h_a9fb13c4ea6c76278d7404cacc032167c}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a35fe02dc9db2af129b09511aba0c1423}\label{da_8h_a35fe02dc9db2af129b09511aba0c1423}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (std\+::complex$<$ double $>$ complex\+\_\+number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_af247fb47bd6d4793239a9918b37e5dd7}\label{da_8h_af247fb47bd6d4793239a9918b37e5dd7}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_a91936815447eaa209c5195a0945abd2a}\label{da_8h_a91936815447eaa209c5195a0945abd2a}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (std\+::complex$<$ double $>$ complex\+\_\+number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a8e9c1c7a3db000001d23962bd41bf9c6}\label{da_8h_a8e9c1c7a3db000001d23962bd41bf9c6}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_ad48468b2f9c8cee8fafbabd2cacca7d1}\label{da_8h_ad48468b2f9c8cee8fafbabd2cacca7d1}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (std\+::complex$<$ double $>$ complex\+\_\+number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a2dcfa8c7a8dfebf08b13ccfb223e8cbb}\label{da_8h_a2dcfa8c7a8dfebf08b13ccfb223e8cbb}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector, std\+::complex$<$ double $>$ complex\+\_\+number)
\item 
\mbox{\Hypertarget{da_8h_aa6eb00ea923ae9229c86b449a7ab9fea}\label{da_8h_aa6eb00ea923ae9229c86b449a7ab9fea}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (std\+::complex$<$ double $>$ complex\+\_\+number, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a056cd96d4fde5ac5b3b7bb1cc84ab0ea}\label{da_8h_a056cd96d4fde5ac5b3b7bb1cc84ab0ea}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator+} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+1, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_abacb423713b3505bf0a35ec5ac2e5953}\label{da_8h_abacb423713b3505bf0a35ec5ac2e5953}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator-\/} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+1, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_a9d90daef98a4f872fcbc9711583f7caf}\label{da_8h_a9d90daef98a4f872fcbc9711583f7caf}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator$\ast$} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+1, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_a353189931e7f845293298a94b7dce27c}\label{da_8h_a353189931e7f845293298a94b7dce27c}} 
std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ {\bfseries operator/} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+1, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector\+\_\+2)
\item 
\mbox{\Hypertarget{da_8h_a2b3463ed8238ad69add0583e50b8dc59}\label{da_8h_a2b3463ed8238ad69add0583e50b8dc59}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries sqrt} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a33a452b6c1f802b876c0df6c60487861}\label{da_8h_a33a452b6c1f802b876c0df6c60487861}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries exp} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a48795a7128e306aecb580bacf1eab595}\label{da_8h_a48795a7128e306aecb580bacf1eab595}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries log} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a749f5b1556c7f3d1af5b2d749ca749ee}\label{da_8h_a749f5b1556c7f3d1af5b2d749ca749ee}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries sin} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_ab1a052ed75e7a4f6cd0403ad0aaa9d2f}\label{da_8h_ab1a052ed75e7a4f6cd0403ad0aaa9d2f}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries cos} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a1cf3c2f3379994543b99ccda65fe9fc6}\label{da_8h_a1cf3c2f3379994543b99ccda65fe9fc6}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries tan} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_aa8f78c203424415b0889942673353e64}\label{da_8h_aa8f78c203424415b0889942673353e64}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries asin} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a949cd32d0319b9a4f43bcf6b192cd4a9}\label{da_8h_a949cd32d0319b9a4f43bcf6b192cd4a9}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries acos} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \mbox{\hyperlink{da_8h_acd90e24b73c9d358830e7e69d9d630a6}{atan}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Calculate the arctan of the given DA vector. Use formula 4.\+4.\+34 and 4.\+4.\+42 in the Handbook of Mathematical Functions by Milton Abramowitz and Irene A. Stegun. Assume z0 is the constant part of the given DA vector z and dz = z -\/ z0. In 4.\+4.\+34, let z1 = z0 and z2 = dz/(1+z$\ast$z0), then the right hand size of 4.\+4.\+34 is atan(z). So we get atan(z) = atan(z0) + atan(z2). Use 4.\+4.\+42 to calculate atan(z2). \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_adc9373b83082540851aedcd529af14a8}\label{da_8h_adc9373b83082540851aedcd529af14a8}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries sinh} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a572743c13b696ecef93c10e74237969e}\label{da_8h_a572743c13b696ecef93c10e74237969e}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries cosh} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_af63923c4fbe9c11020fc8ea26a2f946b}\label{da_8h_af63923c4fbe9c11020fc8ea26a2f946b}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries tanh} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_ae3b2a03dc6ddba9015479e44672d0da7}\label{da_8h_ae3b2a03dc6ddba9015479e44672d0da7}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries pow} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, const int order)
\item 
\mbox{\Hypertarget{da_8h_a2b9c9a42379d4d6631ba82c1fa2d2981}\label{da_8h_a2b9c9a42379d4d6631ba82c1fa2d2981}} 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} {\bfseries pow} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector, const double order)
\item 
\mbox{\Hypertarget{da_8h_ac1322dd7830ae7ca7137be0185a9d4af}\label{da_8h_ac1322dd7830ae7ca7137be0185a9d4af}} 
double {\bfseries abs} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a4b793a27f1c468885e7752373e587648}\label{da_8h_a4b793a27f1c468885e7752373e587648}} 
double {\bfseries abs} (const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&complex\+\_\+dav)
\item 
\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \mbox{\hyperlink{da_8h_afe49af6192e3a686283d848f4a832b83}{erf}} (const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&x)
\begin{DoxyCompactList}\small\item\em error function for a DA vector Calculate the error function value of the input DA vector. The \mbox{\hyperlink{da_8cc_afe49af6192e3a686283d848f4a832b83}{erf()}} in math.\+h is used to calculate the cosntant apart. 2/sqrt(pi)$\ast$exp(-\/x$^\wedge$2) is the derivative of the error function, by which the high order terms could be calculated. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{da_8h_a9bff008e98350cfb096c984c04bbd872}\label{da_8h_a9bff008e98350cfb096c984c04bbd872}} 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&os, const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&da\+\_\+vector)
\item 
\mbox{\Hypertarget{da_8h_a93d12308faaf4935f2c4a72a05225b7f}\label{da_8h_a93d12308faaf4935f2c4a72a05225b7f}} 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&os, const std\+::complex$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&cd\+\_\+vector)
\item 
void \mbox{\hyperlink{da_8h_aa3749e2d2d14985277e012363a78d3e7}{inv\+\_\+map}} (std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ivecs, int dim, std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&ovecs)
\begin{DoxyCompactList}\small\item\em Calculate the inverse map of a given map. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_base}{Base}} \mbox{\hyperlink{da_8h_a3d82aa3a9e60ebd9953b16b9b7614e8e}{da}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
DA wrapper for the extended tpsa code. 

Defines the \mbox{\hyperlink{struct_d_a_vector}{DAVector}} class and the \mbox{\hyperlink{struct_base}{Base}} class. \begin{DoxyAuthor}{Author}
He Zhang @email \href{mailto:hezhang@jlab.org}{\texttt{ hezhang@jlab.\+org}} 
\end{DoxyAuthor}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{da_8h_acd90e24b73c9d358830e7e69d9d630a6}\label{da_8h_acd90e24b73c9d358830e7e69d9d630a6}} 
\index{da.h@{da.h}!atan@{atan}}
\index{atan@{atan}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{atan()}{atan()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_d_a_vector}{DAVector}} atan (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector }\end{DoxyParamCaption})}



Calculate the arctan of the given DA vector. Use formula 4.\+4.\+34 and 4.\+4.\+42 in the Handbook of Mathematical Functions by Milton Abramowitz and Irene A. Stegun. Assume z0 is the constant part of the given DA vector z and dz = z -\/ z0. In 4.\+4.\+34, let z1 = z0 and z2 = dz/(1+z$\ast$z0), then the right hand size of 4.\+4.\+34 is atan(z). So we get atan(z) = atan(z0) + atan(z2). Use 4.\+4.\+42 to calculate atan(z2). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em DA} & vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
DA vector. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a9f08d1308badc3e175572d7c25948604}\label{da_8h_a9f08d1308badc3e175572d7c25948604}} 
\index{da.h@{da.h}!compare\_da\_vectors@{compare\_da\_vectors}}
\index{compare\_da\_vectors@{compare\_da\_vectors}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{compare\_da\_vectors()}{compare\_da\_vectors()}}
{\footnotesize\ttfamily bool compare\+\_\+da\+\_\+vectors (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{a,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{b,  }\item[{double}]{eps }\end{DoxyParamCaption})}



Compare two DA vectors. Compare two DA vectors element by element. If the relative error of each element is less than a given value, return true; otherwise return false. 


\begin{DoxyParams}{Parameters}
{\em a} & DA vector. \\
\hline
{\em b} & DA vector. \\
\hline
{\em eps} & Defines the upper limit of the relative errors for all the elements. Should be positive. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True or false. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a4ce8ca67305300c7278dc9f4c56483db}\label{da_8h_a4ce8ca67305300c7278dc9f4c56483db}} 
\index{da.h@{da.h}!da\_clear@{da\_clear}}
\index{da\_clear@{da\_clear}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_clear()}{da\_clear()}}
{\footnotesize\ttfamily void da\+\_\+clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Destroy the DA environment and release memory. This function should only be called when all the DAVectors are out of scope. Otherwise it will cause a segment fault. 

\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_ae6865e8dd89daf74239153eb2f4f69b9}\label{da_8h_ae6865e8dd89daf74239153eb2f4f69b9}} 
\index{da.h@{da.h}!da\_composition@{da\_composition}}
\index{da\_composition@{da\_composition}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_composition()}{da\_composition()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void da\+\_\+composition (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ivecs,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{v,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ovecs }\end{DoxyParamCaption})}



Composition of a group of DA vectors with another group of DA vectors. Calculate the composition of two groups of DA vectors, and save the result into the third group of DA vectors. Call the first group of DA vectors, ivecs, as f, which includes n DA vectors\+: f\+\_\+1, f\+\_\+2, ..., f\+\_\+n. The second group of DA vectors, v, should contain the same number of DA vectors as the number of DA bases. Call the third group of DA vectors, ovecs, as g, which also includes n DA vectors\+: g\+\_\+1, g\+\_\+2, ..., g\+\_\+n. g = f(v), or g\+\_\+1 = f\+\_\+1(v), g\+\_\+2 = f\+\_\+2(v), ..., g\+\_\+n = f\+\_\+n(v). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ivecs} & DA vectors. \\
\hline
\mbox{\texttt{ in}}  & {\em v} & DA vectors. \\
\hline
\mbox{\texttt{ out}}  & {\em ovecs} & Result DA vectors. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_adc6fca2f8f28480b828974eb3fc69fee}\label{da_8h_adc6fca2f8f28480b828974eb3fc69fee}} 
\index{da.h@{da.h}!da\_composition@{da\_composition}}
\index{da\_composition@{da\_composition}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_composition()}{da\_composition()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void da\+\_\+composition (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ivecs,  }\item[{std\+::vector$<$ double $>$ \&}]{v,  }\item[{std\+::vector$<$ double $>$ \&}]{ovecs }\end{DoxyParamCaption})}



Submitting all the bases for a group of DA vectors with given values. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ivecs} & A group of DA Vectors. \\
\hline
\mbox{\texttt{ in}}  & {\em v} & The values for all the bases. \\
\hline
\mbox{\texttt{ out}}  & {\em ovecs} & Results. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_af02c5d525c7bebcec8d951edef18fd22}\label{da_8h_af02c5d525c7bebcec8d951edef18fd22}} 
\index{da.h@{da.h}!da\_composition@{da\_composition}}
\index{da\_composition@{da\_composition}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_composition()}{da\_composition()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void da\+\_\+composition (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ivecs,  }\item[{std\+::vector$<$ std\+::complex$<$ double $>$$>$ \&}]{v,  }\item[{std\+::vector$<$ std\+::complex$<$ double $>$$>$ \&}]{ovecs }\end{DoxyParamCaption})}



Submitting all the bases for a group of DA vectors with given complex values. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ivecs} & A group of DA Vectors. \\
\hline
\mbox{\texttt{ in}}  & {\em v} & The complex values for all the bases. \\
\hline
\mbox{\texttt{ out}}  & {\em ovecs} & Results. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a34a626191c5eb0ff6d9ad13f14fb0e13}\label{da_8h_a34a626191c5eb0ff6d9ad13f14fb0e13}} 
\index{da.h@{da.h}!da\_der@{da\_der}}
\index{da\_der@{da\_der}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_der()}{da\_der()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_d_a_vector}{DAVector}} da\+\_\+der (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector,  }\item[{unsigned int}]{base\+\_\+id }\end{DoxyParamCaption})}



Take derivative of a da vector w.\+r.\+t. a specific base. 


\begin{DoxyParams}{Parameters}
{\em da\+\_\+vector} & The input da vector. \\
\hline
{\em base\+\_\+id} & Id of the base. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
da vector as the derivation result. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a2ccc5e74773f19981185141ac5f89cbf}\label{da_8h_a2ccc5e74773f19981185141ac5f89cbf}} 
\index{da.h@{da.h}!da\_der@{da\_der}}
\index{da\_der@{da\_der}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_der()}{da\_der()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void da\+\_\+der (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector,  }\item[{unsigned int}]{base\+\_\+id,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector\+\_\+der }\end{DoxyParamCaption})}



Take derivative of a da vector w.\+r.\+t. a specific base. 


\begin{DoxyParams}{Parameters}
{\em da\+\_\+vector} & The input da vector. \\
\hline
{\em base\+\_\+id} & Id of the base. \\
\hline
{\em da\+\_\+vector\+\_\+der} & The output da vector. Should be different with the input vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_ad61827eba074ba0f0a85811822025887}\label{da_8h_ad61827eba074ba0f0a85811822025887}} 
\index{da.h@{da.h}!da\_init@{da\_init}}
\index{da\_init@{da\_init}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_init()}{da\_init()}}
{\footnotesize\ttfamily int da\+\_\+init (\begin{DoxyParamCaption}\item[{unsigned int}]{da\+\_\+order,  }\item[{unsigned int}]{num\+\_\+da\+\_\+variables,  }\item[{unsigned int}]{num\+\_\+da\+\_\+vectors,  }\item[{bool}]{table }\end{DoxyParamCaption})}



Initialize the DA environment. This function initialize the DA environment w.\+r.\+t. the given DA order and the number of bases. A memory pool is created for the given number of DA vectors, which should be large enough for perspective calculations. \mbox{\hyperlink{struct_base}{Base}} vectors are also created. The i-\/th base can be accessed as da\mbox{[}i\mbox{]}. This function should be called before any DA calculation. 


\begin{DoxyParams}{Parameters}
{\em da\+\_\+order} & Highest order of a DA Vector. \\
\hline
{\em num\+\_\+da\+\_\+variables} & Number of bases. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
num\+\_\+da\+\_\+vectors Size of the DA memory pool. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_ab36b8038e76c52468949f8707d3d53cf}\label{da_8h_ab36b8038e76c52468949f8707d3d53cf}} 
\index{da.h@{da.h}!da\_int@{da\_int}}
\index{da\_int@{da\_int}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_int()}{da\_int()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_d_a_vector}{DAVector}} da\+\_\+int (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector,  }\item[{unsigned int}]{base\+\_\+id }\end{DoxyParamCaption})}



Integrate a da vector w.\+r.\+t. a specific base. 


\begin{DoxyParams}{Parameters}
{\em da\+\_\+vector} & The input da vector. \\
\hline
{\em base\+\_\+id} & Id of the base. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
da vector as the integration result. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_afce2e888b1204dc16e0c1f43311b4b85}\label{da_8h_afce2e888b1204dc16e0c1f43311b4b85}} 
\index{da.h@{da.h}!da\_int@{da\_int}}
\index{da\_int@{da\_int}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_int()}{da\_int()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void da\+\_\+int (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector,  }\item[{unsigned int}]{base\+\_\+id,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{da\+\_\+vector\+\_\+int }\end{DoxyParamCaption})}



Integrate a da vector w.\+r.\+t. a specific base. 


\begin{DoxyParams}{Parameters}
{\em da\+\_\+vector} & The input da vector. \\
\hline
{\em base\+\_\+id} & Id of the base. \\
\hline
{\em da\+\_\+vector\+\_\+int} & The output da vector. Should be different with the input vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a7ce0828d83881579af4e2bf2f1c0ae48}\label{da_8h_a7ce0828d83881579af4e2bf2f1c0ae48}} 
\index{da.h@{da.h}!da\_remain@{da\_remain}}
\index{da\_remain@{da\_remain}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_remain()}{da\_remain()}}
{\footnotesize\ttfamily int da\+\_\+remain (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Check the remaining capacity in the DA pool. 

\begin{DoxyReturn}{Returns}
The maximum number of DA vectors that can be created in the remaining place of the pool. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a1fce1be893d2c00666779278f3ce0967}\label{da_8h_a1fce1be893d2c00666779278f3ce0967}} 
\index{da.h@{da.h}!da\_set\_eps@{da\_set\_eps}}
\index{da\_set\_eps@{da\_set\_eps}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_set\_eps()}{da\_set\_eps()}}
{\footnotesize\ttfamily void da\+\_\+set\+\_\+eps (\begin{DoxyParamCaption}\item[{double}]{eps }\end{DoxyParamCaption})}



Set the cut-\/off value for DA coefficients.\+If the abs value of an coefficient is less than eps, it will be set to zero. 


\begin{DoxyParams}{Parameters}
{\em eps} & The cut-\/off value for DA coefficients. Should be greater than zero. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_af25c09dac7cce3378e9b32d29b0f3976}\label{da_8h_af25c09dac7cce3378e9b32d29b0f3976}} 
\index{da.h@{da.h}!da\_substitute@{da\_substitute}}
\index{da\_substitute@{da\_substitute}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_substitute()}{da\_substitute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void da\+\_\+substitute (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{iv,  }\item[{std\+::vector$<$ unsigned int $>$ \&}]{base\+\_\+id,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{v,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{ov }\end{DoxyParamCaption})}



Substitute DA vectors to the specific bases in a DA vector. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em iv} & A DA vector. \\
\hline
\mbox{\texttt{ in}}  & {\em base\+\_\+id} & The ordinal numbers of the bases. \\
\hline
\mbox{\texttt{ in}}  & {\em v} & The DA vectors to substitute. The size of v should be equal to the size of base\+\_\+id. \\
\hline
\mbox{\texttt{ out}}  & {\em ov} & The DA vector that saves the result. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a9fcd9472006662f06ee3229933c01688}\label{da_8h_a9fcd9472006662f06ee3229933c01688}} 
\index{da.h@{da.h}!da\_substitute@{da\_substitute}}
\index{da\_substitute@{da\_substitute}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_substitute()}{da\_substitute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void da\+\_\+substitute (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{iv,  }\item[{unsigned int}]{base\+\_\+id,  }\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{v,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{ov }\end{DoxyParamCaption})}



Substitute a DA vector to a specific base in a given DA Vector. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em iv} & A DA vector. \\
\hline
\mbox{\texttt{ in}}  & {\em base\+\_\+id} & The ordinal number of the base. \\
\hline
\mbox{\texttt{ in}}  & {\em v} & The DA vector to substitute. \\
\hline
\mbox{\texttt{ out}}  & {\em ov} & The DA vector that saves the result. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a6d59d2090f0c4361d2178975f2ee30b6}\label{da_8h_a6d59d2090f0c4361d2178975f2ee30b6}} 
\index{da.h@{da.h}!da\_substitute@{da\_substitute}}
\index{da\_substitute@{da\_substitute}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_substitute()}{da\_substitute()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void da\+\_\+substitute (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ivecs,  }\item[{std\+::vector$<$ unsigned int $>$ \&}]{base\+\_\+id,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{v,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ovecs }\end{DoxyParamCaption})}



Substitute DA vectors to the specific bases in a group of DA vectors. 


\begin{DoxyParams}{Parameters}
{\em ivecs} & A group of DA Vectors. \\
\hline
{\em base\+\_\+id} & The ordinal numbers for the bases. \\
\hline
{\em v} & The DA vectors to substitute. The size of v should be equal to the size of base\+\_\+id. \\
\hline
{\em ovecs} & The DA vectors that saves the result. The size of ovecs should be equal to the size of ivecs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_aada7a3f3aba16d78f60b99266b10e5fa}\label{da_8h_aada7a3f3aba16d78f60b99266b10e5fa}} 
\index{da.h@{da.h}!da\_substitute\_const@{da\_substitute\_const}}
\index{da\_substitute\_const@{da\_substitute\_const}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da\_substitute\_const()}{da\_substitute\_const()}}
{\footnotesize\ttfamily void da\+\_\+substitute\+\_\+const (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{iv,  }\item[{unsigned int}]{base\+\_\+id,  }\item[{double}]{x,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{ov }\end{DoxyParamCaption})}



Substitute the given value to the specific base in a DA vector. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em iv} & A DA vector. \\
\hline
\mbox{\texttt{ in}}  & {\em base\+\_\+id} & The ordinal number of the base. \\
\hline
\mbox{\texttt{ in}}  & {\em x} & The alue to substitute. \\
\hline
\mbox{\texttt{ out}}  & {\em ov} & The DA vector that saves the result. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_ad2fd76384773f1538658cdfebb4c4a08}\label{da_8h_ad2fd76384773f1538658cdfebb4c4a08}} 
\index{da.h@{da.h}!devide\_by\_element@{devide\_by\_element}}
\index{devide\_by\_element@{devide\_by\_element}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{devide\_by\_element()}{devide\_by\_element()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_d_a_vector}{DAVector}} devide\+\_\+by\+\_\+element (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{t,  }\item[{\mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{b }\end{DoxyParamCaption})}



Devide two DA vectors element by element. Devide \mbox{\hyperlink{struct_d_a_vector}{DAVector}} t by \mbox{\hyperlink{struct_d_a_vector}{DAVector}} b element by element. If the the element in b is zero, use the respective element in t as the result for that element. 


\begin{DoxyParams}{Parameters}
{\em t} & DA vector. \\
\hline
{\em b} & DA vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
DA vector. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_afe49af6192e3a686283d848f4a832b83}\label{da_8h_afe49af6192e3a686283d848f4a832b83}} 
\index{da.h@{da.h}!erf@{erf}}
\index{erf@{erf}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{erf()}{erf()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_d_a_vector}{DAVector}} erf (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_d_a_vector}{DAVector}} \&}]{x }\end{DoxyParamCaption})}



error function for a DA vector Calculate the error function value of the input DA vector. The \mbox{\hyperlink{da_8cc_afe49af6192e3a686283d848f4a832b83}{erf()}} in math.\+h is used to calculate the cosntant apart. 2/sqrt(pi)$\ast$exp(-\/x$^\wedge$2) is the derivative of the error function, by which the high order terms could be calculated. 


\begin{DoxyParams}{Parameters}
{\em x} & The input DA vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
erf(x) as a DA vector. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_aa3749e2d2d14985277e012363a78d3e7}\label{da_8h_aa3749e2d2d14985277e012363a78d3e7}} 
\index{da.h@{da.h}!inv\_map@{inv\_map}}
\index{inv\_map@{inv\_map}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{inv\_map()}{inv\_map()}}
{\footnotesize\ttfamily void inv\+\_\+map (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ivecs,  }\item[{int}]{dim,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_d_a_vector}{DAVector}} $>$ \&}]{ovecs }\end{DoxyParamCaption})}



Calculate the inverse map of a given map. 


\begin{DoxyParams}{Parameters}
{\em ivecs} & Saves the input map with dim da vectors. \\
\hline
{\em dim} & Number of da vectors and number of bases used in the map. \\
\hline
{\em ovecs} & Saves the output map. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void. 
\end{DoxyReturn}
\mbox{\Hypertarget{da_8h_a639c9fb588c015dc76640cf52662a3b5}\label{da_8h_a639c9fb588c015dc76640cf52662a3b5}} 
\index{da.h@{da.h}!trim\_whitespace@{trim\_whitespace}}
\index{trim\_whitespace@{trim\_whitespace}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{trim\_whitespace()}{trim\_whitespace()}}
{\footnotesize\ttfamily std\+::string trim\+\_\+whitespace (\begin{DoxyParamCaption}\item[{std\+::string}]{input\+\_\+line }\end{DoxyParamCaption})}



Trim the spaces at the head and the tail of the string. 


\begin{DoxyParams}{Parameters}
{\em input\+\_\+line} & The string to trim. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The string with all the spaces at the head and the tail trimmed. 
\end{DoxyReturn}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{da_8h_a3d82aa3a9e60ebd9953b16b9b7614e8e}\label{da_8h_a3d82aa3a9e60ebd9953b16b9b7614e8e}} 
\index{da.h@{da.h}!da@{da}}
\index{da@{da}!da.h@{da.h}}
\doxysubsubsection{\texorpdfstring{da}{da}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_base}{Base}} da\hspace{0.3cm}{\ttfamily [extern]}}

Bases for DA calculations. The i-\/th base can be accessed as da\mbox{[}i\mbox{]}. ~\newline
 