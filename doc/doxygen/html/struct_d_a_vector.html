<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cppTPSA: DAVector Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cppTPSA
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_d_a_vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="struct_d_a_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DAVector Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators.  
 <a href="struct_d_a_vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="da_8h_source.html">da.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99e3cd385c2a8ba85a55283446eb47f0"><td class="memItemLeft" align="right" valign="top"><a id="a99e3cd385c2a8ba85a55283446eb47f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DAVector</b> (const <a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a99e3cd385c2a8ba85a55283446eb47f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf1ec2c14ca01aad172c4c85337803c"><td class="memItemLeft" align="right" valign="top"><a id="aabf1ec2c14ca01aad172c4c85337803c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DAVector</b> (<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:aabf1ec2c14ca01aad172c4c85337803c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc9ed440ecd6c68b644f266f4aabd15"><td class="memItemLeft" align="right" valign="top"><a id="a8cc9ed440ecd6c68b644f266f4aabd15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DAVector</b> (double x)</td></tr>
<tr class="separator:a8cc9ed440ecd6c68b644f266f4aabd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f699f6a45fb6bda50dd4389d7b33686"><td class="memItemLeft" align="right" valign="top"><a id="a4f699f6a45fb6bda50dd4389d7b33686"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DAVector</b> (int i)</td></tr>
<tr class="separator:a4f699f6a45fb6bda50dd4389d7b33686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5253e4312ca9ca5e68859f706f9f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a6d5253e4312ca9ca5e68859f706f9f2c">print</a> () const</td></tr>
<tr class="separator:a6d5253e4312ca9ca5e68859f706f9f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ef34ddb1dce8bead6d43a24b3fb23e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a00ef34ddb1dce8bead6d43a24b3fb23e">con</a> () const</td></tr>
<tr class="separator:a00ef34ddb1dce8bead6d43a24b3fb23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295d0ae4da5ab95ae2a367365d521f64"><td class="memItemLeft" align="right" valign="top"><a id="a295d0ae4da5ab95ae2a367365d521f64"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a295d0ae4da5ab95ae2a367365d521f64">length</a> () const</td></tr>
<tr class="memdesc:a295d0ae4da5ab95ae2a367365d521f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the DA vector. <br /></td></tr>
<tr class="separator:a295d0ae4da5ab95ae2a367365d521f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7180677f26baf2a1ac32efad7a2bf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#acc7180677f26baf2a1ac32efad7a2bf5">n_element</a> () const</td></tr>
<tr class="separator:acc7180677f26baf2a1ac32efad7a2bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8746be0ebf79a6f1306f134f2c732606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a8746be0ebf79a6f1306f134f2c732606">element</a> (unsigned int i, unsigned int *c, double &amp;elem) const</td></tr>
<tr class="memdesc:a8746be0ebf79a6f1306f134f2c732606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases.  <a href="struct_d_a_vector.html#a8746be0ebf79a6f1306f134f2c732606">More...</a><br /></td></tr>
<tr class="separator:a8746be0ebf79a6f1306f134f2c732606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5a753fb040155746a04f5cd01b0c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a3c5a753fb040155746a04f5cd01b0c8b">element</a> (unsigned int i, std::vector&lt; unsigned int &gt; &amp;c, double &amp;elem) const</td></tr>
<tr class="memdesc:a3c5a753fb040155746a04f5cd01b0c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of vector c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases.  <a href="struct_d_a_vector.html#a3c5a753fb040155746a04f5cd01b0c8b">More...</a><br /></td></tr>
<tr class="separator:a3c5a753fb040155746a04f5cd01b0c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cabf406529dff2d2a27c340f60826e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#aa2cabf406529dff2d2a27c340f60826e">element</a> (int i)</td></tr>
<tr class="memdesc:aa2cabf406529dff2d2a27c340f60826e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a specific element. Given the ordinal number of the element, return the value. The ordinal number starts from zero, following c++ tradition.  <a href="struct_d_a_vector.html#aa2cabf406529dff2d2a27c340f60826e">More...</a><br /></td></tr>
<tr class="separator:aa2cabf406529dff2d2a27c340f60826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53070a432d184992aaaa69e1cb9f609d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a53070a432d184992aaaa69e1cb9f609d">element</a> (std::vector&lt; int &gt; idx)</td></tr>
<tr class="memdesc:a53070a432d184992aaaa69e1cb9f609d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a specific element. Given the order pattern of the element, return the value. The size of the vector idx should be equal to the base number. For example, assuming the base number is three, idx = {nx, ny, nz} referring to the element (x^nx)*(y^ny)*(z^nz), where x, y, and z are the bases.  <a href="struct_d_a_vector.html#a53070a432d184992aaaa69e1cb9f609d">More...</a><br /></td></tr>
<tr class="separator:a53070a432d184992aaaa69e1cb9f609d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982ae9c1ff348c191a0c53018850bde6"><td class="memItemLeft" align="right" valign="top"><a id="a982ae9c1ff348c191a0c53018850bde6"></a>
std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>element_orders</b> (int i)</td></tr>
<tr class="separator:a982ae9c1ff348c191a0c53018850bde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5e73d838b0178ecfa6910052a59fda"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#abe5e73d838b0178ecfa6910052a59fda">norm</a> ()</td></tr>
<tr class="memdesc:abe5e73d838b0178ecfa6910052a59fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the norm of the DA vector, e.g. the maximum of the absolute value of the DA coefficients.  <a href="struct_d_a_vector.html#abe5e73d838b0178ecfa6910052a59fda">More...</a><br /></td></tr>
<tr class="separator:abe5e73d838b0178ecfa6910052a59fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebbd9ec0e71c32141064721ba2f10cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#aeebbd9ec0e71c32141064721ba2f10cb">weighted_norm</a> (double w)</td></tr>
<tr class="memdesc:aeebbd9ec0e71c32141064721ba2f10cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the weighted norm of the DA vector. Calculate the absolute value of coef*w^n for each term, where coef is the coefficient of the term, n is the total order of the term and w is the weight. Return the maximum of the calculation.  <a href="struct_d_a_vector.html#aeebbd9ec0e71c32141064721ba2f10cb">More...</a><br /></td></tr>
<tr class="separator:aeebbd9ec0e71c32141064721ba2f10cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08078f536d095d8c7423ea2989a7854c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a08078f536d095d8c7423ea2989a7854c">set_element</a> (int *c, double elem)</td></tr>
<tr class="memdesc:a08078f536d095d8c7423ea2989a7854c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_d_a_vector.html#a08078f536d095d8c7423ea2989a7854c">More...</a><br /></td></tr>
<tr class="separator:a08078f536d095d8c7423ea2989a7854c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403b07be6cfbac43bfa05fef187caab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a4403b07be6cfbac43bfa05fef187caab">set_element</a> (std::vector&lt; int &gt; idx, double elem)</td></tr>
<tr class="memdesc:a4403b07be6cfbac43bfa05fef187caab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a specific element.  <a href="struct_d_a_vector.html#a4403b07be6cfbac43bfa05fef187caab">More...</a><br /></td></tr>
<tr class="separator:a4403b07be6cfbac43bfa05fef187caab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c85003e3b334ca94135b4874c36f7e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a0c85003e3b334ca94135b4874c36f7e3">reset</a> ()</td></tr>
<tr class="separator:a0c85003e3b334ca94135b4874c36f7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104928f5ba59b6ce42636646670048c4"><td class="memItemLeft" align="right" valign="top"><a id="a104928f5ba59b6ce42636646670048c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a104928f5ba59b6ce42636646670048c4">reset_const</a> (double x=0)</td></tr>
<tr class="memdesc:a104928f5ba59b6ce42636646670048c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the value to the given number. Vector length is set to 1. <br /></td></tr>
<tr class="separator:a104928f5ba59b6ce42636646670048c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d594d154f7e8ec5006e3e223e4cdea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#ad4d594d154f7e8ec5006e3e223e4cdea">clean</a> (const double <a class="el" href="struct_d_a_vector.html#a79bdbee2e35ef552cae7f673632c9f64">eps</a>)</td></tr>
<tr class="memdesc:ad4d594d154f7e8ec5006e3e223e4cdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the given eps.  <a href="struct_d_a_vector.html#ad4d594d154f7e8ec5006e3e223e4cdea">More...</a><br /></td></tr>
<tr class="separator:ad4d594d154f7e8ec5006e3e223e4cdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1494c69478b3b57d5973e86248a7e63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#aa1494c69478b3b57d5973e86248a7e63">clean</a> ()</td></tr>
<tr class="memdesc:aa1494c69478b3b57d5973e86248a7e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the global eps.  <a href="struct_d_a_vector.html#aa1494c69478b3b57d5973e86248a7e63">More...</a><br /></td></tr>
<tr class="separator:aa1494c69478b3b57d5973e86248a7e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c48a1bb5890cefaddbd88098e84025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#ab3c48a1bb5890cefaddbd88098e84025">iszero</a> () const</td></tr>
<tr class="memdesc:ab3c48a1bb5890cefaddbd88098e84025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the abs value of the coefficients in the <a class="el" href="struct_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the cut-off value.  <a href="struct_d_a_vector.html#ab3c48a1bb5890cefaddbd88098e84025">More...</a><br /></td></tr>
<tr class="separator:ab3c48a1bb5890cefaddbd88098e84025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a11746a3dad447e1c489f8f4edcaae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a74a11746a3dad447e1c489f8f4edcaae">iszero</a> (double <a class="el" href="struct_d_a_vector.html#a79bdbee2e35ef552cae7f673632c9f64">eps</a>) const</td></tr>
<tr class="memdesc:a74a11746a3dad447e1c489f8f4edcaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the abs value of the coefficients in the <a class="el" href="struct_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the given value eps.  <a href="struct_d_a_vector.html#a74a11746a3dad447e1c489f8f4edcaae">More...</a><br /></td></tr>
<tr class="separator:a74a11746a3dad447e1c489f8f4edcaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1536a5cbbff18cfdc30c63f600d8e31e"><td class="memItemLeft" align="right" valign="top"><a id="a1536a5cbbff18cfdc30c63f600d8e31e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a1536a5cbbff18cfdc30c63f600d8e31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e8151a620dabaec3ea3d817cfa62b8"><td class="memItemLeft" align="right" valign="top"><a id="a97e8151a620dabaec3ea3d817cfa62b8"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a97e8151a620dabaec3ea3d817cfa62b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94691d8c67e45550f23b6560ad7f9a7d"><td class="memItemLeft" align="right" valign="top"><a id="a94691d8c67e45550f23b6560ad7f9a7d"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:a94691d8c67e45550f23b6560ad7f9a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad918757f17d0e69d88faf409fa3e68d6"><td class="memItemLeft" align="right" valign="top"><a id="ad918757f17d0e69d88faf409fa3e68d6"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (double x)</td></tr>
<tr class="separator:ad918757f17d0e69d88faf409fa3e68d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a4cac6079ac29055d8d68a87ae3ffe"><td class="memItemLeft" align="right" valign="top"><a id="a07a4cac6079ac29055d8d68a87ae3ffe"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (int x)</td></tr>
<tr class="separator:a07a4cac6079ac29055d8d68a87ae3ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf543a11ce6aa68ea01237f80b1eb17"><td class="memItemLeft" align="right" valign="top"><a id="afdf543a11ce6aa68ea01237f80b1eb17"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:afdf543a11ce6aa68ea01237f80b1eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac506591d2371fad34a78092932452c8e"><td class="memItemLeft" align="right" valign="top"><a id="ac506591d2371fad34a78092932452c8e"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&amp;da_vector_)</td></tr>
<tr class="separator:ac506591d2371fad34a78092932452c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e0b5e4810812a426c15313d012eaa0"><td class="memItemLeft" align="right" valign="top"><a id="ad2e0b5e4810812a426c15313d012eaa0"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (double x)</td></tr>
<tr class="separator:ad2e0b5e4810812a426c15313d012eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fdc56cf1dcc9107217796634255411"><td class="memItemLeft" align="right" valign="top"><a id="a16fdc56cf1dcc9107217796634255411"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (int x)</td></tr>
<tr class="separator:a16fdc56cf1dcc9107217796634255411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a2280559d15f94508c47ed3db7436b"><td class="memItemLeft" align="right" valign="top"><a id="ab5a2280559d15f94508c47ed3db7436b"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:ab5a2280559d15f94508c47ed3db7436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8084b5f039993f96df4f5c8b8b675d7a"><td class="memItemLeft" align="right" valign="top"><a id="a8084b5f039993f96df4f5c8b8b675d7a"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&amp;da_vector_)</td></tr>
<tr class="separator:a8084b5f039993f96df4f5c8b8b675d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b69dccb8db6428d49a468b2a5ae1c5e"><td class="memItemLeft" align="right" valign="top"><a id="a6b69dccb8db6428d49a468b2a5ae1c5e"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (double x)</td></tr>
<tr class="separator:a6b69dccb8db6428d49a468b2a5ae1c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d73e21b9f1beb87cd7d5819e7b06cf"><td class="memItemLeft" align="right" valign="top"><a id="a97d73e21b9f1beb87cd7d5819e7b06cf"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (int x)</td></tr>
<tr class="separator:a97d73e21b9f1beb87cd7d5819e7b06cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c73ba634615cfc08cbf1a2dccc286d3"><td class="memItemLeft" align="right" valign="top"><a id="a3c73ba634615cfc08cbf1a2dccc286d3"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:a3c73ba634615cfc08cbf1a2dccc286d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f6488f351765b6953b1af7e4cc5412"><td class="memItemLeft" align="right" valign="top"><a id="a13f6488f351765b6953b1af7e4cc5412"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:a13f6488f351765b6953b1af7e4cc5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62cda4ffdc2e4971d5b235697a12269"><td class="memItemLeft" align="right" valign="top"><a id="af62cda4ffdc2e4971d5b235697a12269"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (double x)</td></tr>
<tr class="separator:af62cda4ffdc2e4971d5b235697a12269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb50bc07a621a5749e444fcc9c574026"><td class="memItemLeft" align="right" valign="top"><a id="afb50bc07a621a5749e444fcc9c574026"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (int x)</td></tr>
<tr class="separator:afb50bc07a621a5749e444fcc9c574026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3993d1627af3e846bc8261e61770df7"><td class="memItemLeft" align="right" valign="top"><a id="ac3993d1627af3e846bc8261e61770df7"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;da_vector)</td></tr>
<tr class="separator:ac3993d1627af3e846bc8261e61770df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9d829ed63f0cbd48dfb5381684df1"><td class="memItemLeft" align="right" valign="top"><a id="a98c9d829ed63f0cbd48dfb5381684df1"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&amp;da_vector)</td></tr>
<tr class="separator:a98c9d829ed63f0cbd48dfb5381684df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29099ee8cbc4cc93eb4c9dda43de4411"><td class="memItemLeft" align="right" valign="top"><a id="a29099ee8cbc4cc93eb4c9dda43de4411"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (double x)</td></tr>
<tr class="separator:a29099ee8cbc4cc93eb4c9dda43de4411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff7e67a21ac576a8d6aeed17e6a9ae2"><td class="memItemLeft" align="right" valign="top"><a id="a4ff7e67a21ac576a8d6aeed17e6a9ae2"></a>
<a class="el" href="struct_d_a_vector.html">DAVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (int x)</td></tr>
<tr class="separator:a4ff7e67a21ac576a8d6aeed17e6a9ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1eeb99a92d75ddd495ba8d34ba7a665e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a1eeb99a92d75ddd495ba8d34ba7a665e">dim</a> ()</td></tr>
<tr class="separator:a1eeb99a92d75ddd495ba8d34ba7a665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442d4b491a94164eb52936143b332345"><td class="memItemLeft" align="right" valign="top"><a id="a442d4b491a94164eb52936143b332345"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>order</b> ()</td></tr>
<tr class="separator:a442d4b491a94164eb52936143b332345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68677512679c5151a59e0e6a2306fdee"><td class="memItemLeft" align="right" valign="top"><a id="a68677512679c5151a59e0e6a2306fdee"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>full_length</b> ()</td></tr>
<tr class="separator:a68677512679c5151a59e0e6a2306fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a359a2e0b8e48c6e481b48b5972e7631c"><td class="memItemLeft" align="right" valign="top"><a id="a359a2e0b8e48c6e481b48b5972e7631c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>da_vector_</b></td></tr>
<tr class="separator:a359a2e0b8e48c6e481b48b5972e7631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a79bdbee2e35ef552cae7f673632c9f64"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_d_a_vector.html#a79bdbee2e35ef552cae7f673632c9f64">eps</a> = 1e-16</td></tr>
<tr class="separator:a79bdbee2e35ef552cae7f673632c9f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1494c69478b3b57d5973e86248a7e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1494c69478b3b57d5973e86248a7e63">&#9670;&nbsp;</a></span>clean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::clean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the global eps. </p>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="ad4d594d154f7e8ec5006e3e223e4cdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d594d154f7e8ec5006e3e223e4cdea">&#9670;&nbsp;</a></span>clean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::clean </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a coefficient in the DA Vector to be zero if the abs of the coefficient is less than the given eps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">the</td><td>threshold for zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a00ef34ddb1dce8bead6d43a24b3fb23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ef34ddb1dce8bead6d43a24b3fb23e">&#9670;&nbsp;</a></span>con()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DAVector::con </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the constant element of a DA vector. </p>

</div>
</div>
<a id="a1eeb99a92d75ddd495ba8d34ba7a665e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb99a92d75ddd495ba8d34ba7a665e">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DAVector::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the DA base number. </p>

</div>
</div>
<a id="aa2cabf406529dff2d2a27c340f60826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cabf406529dff2d2a27c340f60826e">&#9670;&nbsp;</a></span>element() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DAVector::element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a specific element. Given the ordinal number of the element, return the value. The ordinal number starts from zero, following c++ tradition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element. </dd></dl>

</div>
</div>
<a id="a53070a432d184992aaaa69e1cb9f609d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53070a432d184992aaaa69e1cb9f609d">&#9670;&nbsp;</a></span>element() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DAVector::element </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of a specific element. Given the order pattern of the element, return the value. The size of the vector idx should be equal to the base number. For example, assuming the base number is three, idx = {nx, ny, nz} referring to the element (x^nx)*(y^ny)*(z^nz), where x, y, and z are the bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The order pattern of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element. </dd></dl>

</div>
</div>
<a id="a3c5a753fb040155746a04f5cd01b0c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5a753fb040155746a04f5cd01b0c8b">&#9670;&nbsp;</a></span>element() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::element </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of vector c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8746be0ebf79a6f1306f134f2c732606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8746be0ebf79a6f1306f134f2c732606">&#9670;&nbsp;</a></span>element() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::element </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value and the order pattern of the specific element. Given the ordinal number of an element, return the value and order pattern of the element. Following the c++ tradition, the ordinal number, i, starts from zero. (In ad_elem, the ordinal number starts from one.) The size of array c should be equal to the number of bases. For example, if i matches the element (x^nx)*(n^ny)*(z^nz), c = {nx, ny, nz}, where x, y, and z are the bases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The ordinal number of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab3c48a1bb5890cefaddbd88098e84025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c48a1bb5890cefaddbd88098e84025">&#9670;&nbsp;</a></span>iszero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DAVector::iszero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all the abs value of the coefficients in the <a class="el" href="struct_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the cut-off value. </p>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="a74a11746a3dad447e1c489f8f4edcaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a11746a3dad447e1c489f8f4edcaae">&#9670;&nbsp;</a></span>iszero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DAVector::iszero </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all the abs value of the coefficients in the <a class="el" href="struct_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> are smaller than the given value eps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eps</td><td>The value to compare with the abs value of the coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="acc7180677f26baf2a1ac32efad7a2bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7180677f26baf2a1ac32efad7a2bf5">&#9670;&nbsp;</a></span>n_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DAVector::n_element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of non-zero element a DA vector. </p>

</div>
</div>
<a id="abe5e73d838b0178ecfa6910052a59fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5e73d838b0178ecfa6910052a59fda">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DAVector::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the norm of the DA vector, e.g. the maximum of the absolute value of the DA coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>The norm of the DA vector. </dd></dl>

</div>
</div>
<a id="a6d5253e4312ca9ca5e68859f706f9f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5253e4312ca9ca5e68859f706f9f2c">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print out a DA vector. </p>

</div>
</div>
<a id="a0c85003e3b334ca94135b4874c36f7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c85003e3b334ca94135b4874c36f7e3">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all element to zero, vector length unchanged. </p>

</div>
</div>
<a id="a08078f536d095d8c7423ea2989a7854c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08078f536d095d8c7423ea2989a7854c">&#9670;&nbsp;</a></span>set_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a4403b07be6cfbac43bfa05fef187caab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4403b07be6cfbac43bfa05fef187caab">&#9670;&nbsp;</a></span>set_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DAVector::set_element </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a specific element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The order pattern of the element. </td></tr>
    <tr><td class="paramname">elem</td><td>The value of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="aeebbd9ec0e71c32141064721ba2f10cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebbd9ec0e71c32141064721ba2f10cb">&#9670;&nbsp;</a></span>weighted_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DAVector::weighted_norm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the weighted norm of the DA vector. Calculate the absolute value of coef*w^n for each term, where coef is the coefficient of the term, n is the total order of the term and w is the weight. Return the maximum of the calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The weight. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The norm of the DA vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a79bdbee2e35ef552cae7f673632c9f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bdbee2e35ef552cae7f673632c9f64">&#9670;&nbsp;</a></span>eps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double DAVector::eps = 1e-16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global threshold of the abs value of <a class="el" href="struct_d_a_vector.html" title="Differential Algebra (DA) Vector A TPS vector with methods. Can be used with most numerical operators...">DAVector</a> coefficients. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>E:/Work/Code/tpsa_lib/include/<a class="el" href="da_8h_source.html">da.h</a></li>
<li>E:/Work/Code/tpsa_lib/src/<a class="el" href="da_8cc.html">da.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="struct_d_a_vector.html">DAVector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
